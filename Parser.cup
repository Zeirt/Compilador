package compilador;

import java_cup.runtime.*;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.File;
import java.util.Scanner;
import compilador.TablaSimbolos;
import java.util.Queue;
import java.util.LinkedList;
import java.util.NoSuchElementException;

parser code
{:

static public TablaSimbolos tablaSimbolos;
static public Queue<String> colaDeclarados; //Utilizado para procesar declaraciones multiples en una linea

/** MAIN - LEER TOKENS */

public static void main (String argv[]) throws Exception
  {
    /*Comprobacacion del nombre del archivo*/
    if(argv.length<1){
    	System.err.println("Uso: java Parser nombreArchivo");
    	System.exit(1);
    }
    /* Asegurarse que la extension del archivo es correcta*/
	int aux = argv[0].indexOf('.');
	if(aux==-1){
		System.err.println("Error: El archivo debe acabar en .prog");
		System.exit(1);
	} else{
		if(!argv[0].substring(aux+1).equals("prog")){
			System.err.println("Error: El archivo debe acabar en .prog");
			System.exit(1);
		}
	}
	/* Inicializaion*/
	File archivo = new File(argv[0]);
    FileReader fr = new FileReader(archivo);
    tablaSimbolos = new TablaSimbolos();
    colaDeclarados = new LinkedList();
    Scan lex = new Scan(fr);
    ParserCup p = new ParserCup(lex);
    p.parse();
}

/** NOTIFICAR ERROR DE SINTAXIS */
public void syntax_error(Symbol s) {
  report_error("Error de sintaxis linea " + s.left, null);
}

/** NOTIFICAR ERROR FATAL Y SALIR */
public void report_fatal_error(String message, Object info) {
  done_parsing();
  report_error("Error de sintaxis fatal : "
  + "No se puede recuperar del error y continuar con el analisis - "
  + message + " ",(Symbol)info);
  report_error("** Final del analisis.", null);
  System.exit(1);
}
:}

//scan with {: return scanner.next_token();:};

// TERMINALES Y NO TERMINALES
terminal PROGRAM, IS, BEGIN, END, VAR, INTEGER, BOOLEAN, READ, WRITE, SKIP, WHILE, DO, IF, THEN, ELSE;
terminal AND, OR, NOT, TRUE, FALSE, ASIGNACION, MENORIGUAL, MENOR, IGUAL, MAYOR, MAYORIGUAL, DISTINTOA;
terminal SUMA, RESTA, MULTIPLICACION, DIVISION, PUNTOCOMA, ABRIRPARENTESIS, CERRARPARENTESIS;
terminal COMA, DOSPUNTOS, ENTERO, IDENTIFICADOR;

non terminal programa, declararProg, bloqueDeclaraciones, declarar, declaracion, bloqueCodigo, condicion, sentencia, expresion;

// PRECEDENCIA DE OPERADORES
precedence left OR, AND, NOT;
precedence left DISTINTOA, MENORIGUAL, IGUAL, MAYORIGUAL, MENOR, MAYOR;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;

// GRAMÁTICA

start with programa;

programa ::= declararProg bloqueDeclaraciones BEGIN bloqueCodigo END {:System.out.println("Programa completo");:}
			 | declararProg BEGIN bloqueCodigo END {:System.out.println("Programa completo sin declaraciones");:};

declararProg ::= PROGRAM IDENTIFICADOR: v IS {:ParserCup.tablaSimbolos.insertarSimbolo((String)v,"pseudo");
												System.out.println("Comanzando programa llamado " + v);:};

bloqueDeclaraciones ::= declarar {:System.out.println("Declaracion acabada");:}
						| declarar bloqueDeclaraciones {:System.out.println("Declaraciones acabadas");:};
						
declarar ::= VAR declaracion DOSPUNTOS: v INTEGER PUNTOCOMA 
			{:System.out.println("Integer declarado");
				while(!ParserCup.colaDeclarados.isEmpty()){
					if (ParserCup.tablaSimbolos.getSimbolo(ParserCup.colaDeclarados.peek()).equals("Void")){
						//No existe en la tabla. Se puede insertar
						String aux = (String)ParserCup.colaDeclarados.remove();
						ParserCup.tablaSimbolos.insertarSimbolo(aux,"Integer");
					}
					else{
						System.err.println("Error semántico: Más de una variable de nombre " + ParserCup.colaDeclarados.remove() + " (Linea " + vleft + ")");
					}
				}
			:}
			| VAR declaracion DOSPUNTOS: v BOOLEAN PUNTOCOMA 
				{:System.out.println("Boolean declarado");
				while(!ParserCup.colaDeclarados.isEmpty()){
					if (ParserCup.tablaSimbolos.getSimbolo(ParserCup.colaDeclarados.peek()).equals("Void")){
						//No existe en la tabla. Se puede insertar
						String aux = (String)ParserCup.colaDeclarados.remove();
						ParserCup.tablaSimbolos.insertarSimbolo(aux,"Boolean");
					}
					else{
						System.err.println("Error semántico: Más de una variable de nombre " + ParserCup.colaDeclarados.remove() + " (Linea " + vleft + ")");
					}
				}
			:}
			| error PUNTOCOMA: p {: System.err.println("Error sintáctico: Declaración mal formada en linea " + pleft);:};

declaracion ::= declaracion COMA IDENTIFICADOR: v {:System.out.println("Más de una variable");
													ParserCup.colaDeclarados.add((String)v);:}
				| IDENTIFICADOR: v {:System.out.println("Una variable");
									ParserCup.colaDeclarados.add((String)v);:};
				
bloqueCodigo ::= sentencia bloqueCodigo {:System.out.println("Bloque codigo");:}
				| sentencia {:System.out.println("Una sentencia de bloque");:};
		
sentencia ::= IDENTIFICADOR: v ASIGNACION expresion PUNTOCOMA 
				{:String aux = ParserCup.tablaSimbolos.getSimbolo((String)v);
					if (aux.equals("Void")){
						//No existe en la tabla. Error
						System.err.println("Error semántico: Asignación a variable no declarada (Linea " + vleft + ", Pos " + vright +")");
					}
					else{ //Si existe, comprobamos tipo
						if(!aux.equals("Integer")){
							//Tipo incorrecto. Error
							System.err.println("Error semántico: Asignación aritmetica a variable tipo " + aux + " (Linea " + vleft + ", Pos " + vright +")");
						}
						else System.out.println("Asignacion Aritmetica");
					}
				:}
				| IDENTIFICADOR: v ASIGNACION condicion PUNTOCOMA 
					{:String aux = ParserCup.tablaSimbolos.getSimbolo((String)v);
						if (aux.equals("Void")){
							//No existe en la tabla. Error
							System.err.println("Error semántico: Asignación a variable no declarada (Linea " + vleft + ", Pos " + vright +")");
						}
						else{ //Si existe, comprobamos tipo
							if(!aux.equals("Boolean")){
								//Tipo incorrecto. Error
								System.err.println("Error semántico: Asignación booleana a variable tipo " + aux + " (Linea " + vleft + ", Pos " + vright +")");
							}
							else System.out.println("Asignacion Booleana");
						}
					:}
				| READ expresion PUNTOCOMA {:
					System.out.println("Read");
				:}
				| WRITE expresion PUNTOCOMA {:
					System.out.println("Write de expresion");
				:}
				| WRITE condicion PUNTOCOMA {:
					System.out.println("Write de condicion");
				:}
				| SKIP {:System.out.println("Skip");:}
				| IF condicion THEN bloqueCodigo END IF PUNTOCOMA {:System.out.println("If simple");:}
				| IF condicion THEN bloqueCodigo ELSE bloqueCodigo END IF PUNTOCOMA {:System.out.println("If con else");:}
				| IF expresion THEN bloqueCodigo END IF PUNTOCOMA {:System.out.println("If simple con expresion!");:}
				| IF expresion THEN bloqueCodigo ELSE bloqueCodigo END IF PUNTOCOMA {:System.out.println("If con else con expresion!");:}
				| WHILE condicion DO bloqueCodigo END WHILE PUNTOCOMA {:System.out.println("Bucle");:}
				| WHILE expresion DO bloqueCodigo END WHILE PUNTOCOMA {:System.out.println("Bucle con expresion!");:}
				| error PUNTOCOMA: p {:System.err.println("Error sintáctico: sentencia mal escrita en linea " + pleft);:};
				
condicion ::= TRUE {:
				RESULT = new String("Boolean");
				System.out.println("Condicion true");
			:}
			| FALSE {:
				RESULT = new String("Boolean");
				System.out.println("Condicion false");
			:}
			| ABRIRPARENTESIS condicion: c1 CERRARPARENTESIS {:
				RESULT = c1;
				System.out.println("Condicion completa");
			:}
			| expresion: e1 DISTINTOA expresion: e2 {:
				if(e1.equals("Integer")&&e2.equals("Integer")){
					RESULT = e1;
					System.out.println("Condicion distintoa");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| expresion: e1 MENORIGUAL expresion: e2 {:
				if(e1.equals("Integer")&&e2.equals("Integer")){
					RESULT = e1;
					System.out.println("Condicion menorigual");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| expresion: e1 IGUAL expresion: e2 {:
				if(e1.equals("Integer")&&e2.equals("Integer")){
					RESULT = e1;
					System.out.println("Condicion igual");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| expresion: e1 MAYORIGUAL expresion: e2 {:
				if(e1.equals("Integer")&&e2.equals("Integer")){
					RESULT = e1;
					System.out.println("Condicion mayorigual");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| expresion: e1 MENOR expresion: e2 {:
				if(e1.equals("Integer")&&e2.equals("Integer")){
					RESULT = e1;
					System.out.println("Condicion menor");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| expresion: e1 MAYOR expresion: e2 {:
				if(e1.equals("Integer")&&e2.equals("Integer")){
					RESULT = e1;
					System.out.println("Condicion mayor");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| NOT condicion: e1 {:
				if(e1.equals("Boolean")){
					RESULT = e1;
					System.out.println("Condicion not simple");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de comparación" + " (Linea " + e1left + ")");
			:}
			| NOT: v expresion: e {:
				if(e.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion not ambigua");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + vleft + ")");
			:}
			| condicion: c1 OR condicion: c2 {:
				if(c1.equals("Boolean")&&c2.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion or simple");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + c1left + ")");
			:}
			| expresion: e1 OR expresion: e2 {:
				if(e1.equals("Boolean")&&e2.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion or ambigua");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + e1left + ")");
			:}
			| expresion: e OR condicion: c {:
				if(e.equals("Boolean")&&c.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion or mixta");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + eleft + ")");
			:}
			| condicion: c OR expresion: e {:
				if(c.equals("Boolean")&&e.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion or mixta");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + cleft + ")");
			:}
			| condicion: c1 AND condicion: c2 {:
				if(c1.equals("Boolean")&&c2.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion and simple");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + c1left + ")");
			:}
			| expresion: e1 AND expresion: e2 {:
				if(e1.equals("Boolean")&&e2.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion and ambigua");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + e1left + ")");
			:}
			| expresion: e AND condicion: c {:
				if(e.equals("Boolean")&&c.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion and mixta");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + cleft + ")");
			:}
			| condicion: c AND expresion: e {:
				if(c.equals("Boolean")&&e.equals("Boolean")){
					RESULT = new String("Boolean");
					System.out.println("Condicion and simple");
				} else System.err.println("Error semántico: Expresión de tipo inesperado en operación booleana" + " (Linea " + cleft + ")");
			:};
			
expresion ::= IDENTIFICADOR: v {:
					String aux = ParserCup.tablaSimbolos.getSimbolo((String)v);
					if (aux.equals("Undefined")){
						//No existe en la tabla. Error
						System.err.println("Error semántico: Llamada a variable no declarada" + " (Linea " + vleft + ", Pos " + vright +")");
					} else {
						RESULT = new String(aux);
					}
					System.out.println("Expresion Identificador tipo " + aux);
				:}
				| ENTERO {:
					RESULT = new String("Integer");
					System.out.println("Expresion Entero");
				:}
				| ABRIRPARENTESIS expresion: e1 CERRARPARENTESIS {:
					RESULT = e1;
					System.out.println("expresion anidada");
				:}
				| expresion: e1 SUMA: v expresion: e2 {:
					if(e1.equals("Integer")&&e2.equals("Integer")){
						RESULT = e1;
						System.out.println("Expresion suma");
					} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de enteros" + " (Linea " + vleft + ")");
				:}
				| expresion: e1 RESTA: v expresion: e2 {:
					if(e1.equals("Integer")&&e2.equals("Integer")){
						RESULT = e1;
						System.out.println("Expresion resto");
					} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de enteros" + " (Linea " + vleft + ")");
				:}
				| expresion: e1 MULTIPLICACION: v expresion: e2 {:
					if(e1.equals("Integer")&&e2.equals("Integer")){
						RESULT = e1;
						System.out.println("Expresion multiplicacion");
					} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de enteros" + " (Linea " + vleft + ")");
				:}
				| expresion: e1 DIVISION: v expresion: e2 {:
					if(e1.equals("Integer")&&e2.equals("Integer")){
						RESULT = e1;
						System.out.println("Expresion división");
					} else System.err.println("Error semántico: Expresión de tipo inesperado en operación de enteros" + " (Linea " + vleft + ")");
				:};